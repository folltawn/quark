use crate::parser::{Program, Stmt, Expr, Value, VarType};
use std::fs;
use std::process::{Command, Stdio};

#[derive(Debug)]
pub enum CompileError {
    Parse(String),
    Io(String),
    Compilation(String),
    NoCompiler,
}

pub struct Compiler;

impl Compiler {
    fn generate_c_code(&self, program: &Program) -> String {
        let mut c_code = String::new();
        
        c_code.push_str("/* Generated by Quark Compiler */\n");
        c_code.push_str("#include <stdio.h>\n");
        c_code.push_str("#include <stdlib.h>\n");
        c_code.push_str("#include <stdbool.h>\n\n");
        
        // Собираем все объявленные переменные
        let mut variables = std::collections::HashMap::new();
        
        for stmt in &program.statements {
            if let Stmt::Declaration { var_type, name, .. } = stmt {
                variables.insert(name.clone(), var_type.clone());
            }
        }
        
        // Объявления переменных
        c_code.push_str("// Variables\n");
        for stmt in &program.statements {
            if let Stmt::Declaration { var_type, name, value } = stmt {
                let c_type = match var_type {
                    VarType::String => "const char*",
                    VarType::Integer => "long long",
                    VarType::Float => "double",
                    VarType::Boolean => "bool",
                };
                
                let c_value = match value {
                    Value::String(s) => {
                        let escaped = s
                            .replace('\\', "\\\\")
                            .replace('\"', "\\\"")
                            .replace('\n', "\\n")
                            .replace('\t', "\\t")
                            .replace('\r', "\\r");
                        format!("\"{}\"", escaped)
                    }
                    Value::Integer(i) => i.to_string(),
                    Value::Float(f) => f.to_string(),
                    Value::Boolean(true) => "true".to_string(),
                    Value::Boolean(false) => "false".to_string(),
                };
                
                c_code.push_str(&format!("{} {} = {};\n", c_type, name, c_value));
            }
        }
        
        c_code.push_str("\nint main() {\n");
        
        // Генерация кода
        for stmt in &program.statements {
            match stmt {
                Stmt::Declaration { .. } => {
                    // Объявления уже были выше
                }
                Stmt::Expression(expr) => {
                    if let Expr::Call { name, args } = expr {
                        if name == "echo" {
                            for arg in args {
                                match arg {
                                    Expr::Literal(value) => {
                                        match value {
                                            Value::String(s) => {
                                                let escaped = s
                                                    .replace('\\', "\\\\")
                                                    .replace('\"', "\\\"")
                                                    .replace('\n', "\\n")
                                                    .replace('\t', "\\t")
                                                    .replace('\r', "\\r")
                                                    .replace('%', "%%");
                                                c_code.push_str(&format!("    printf(\"{}\\n\");\n", escaped));
                                            }
                                            Value::Integer(i) => {
                                                c_code.push_str(&format!("    printf(\"%lld\\n\", {});\n", i));
                                            }
                                            Value::Float(f) => {
                                                c_code.push_str(&format!("    printf(\"%f\\n\", {});\n", f));
                                            }
                                            Value::Boolean(b) => {
                                                c_code.push_str(&format!("    printf(\"{}\\n\");\n", if *b { "true" } else { "false" }));
                                            }
                                        }
                                    }
                                    Expr::Variable(var_name) => {
                                        // Определяем тип переменной для правильного форматирования
                                        if let Some(var_type) = variables.get(var_name) {
                                            match var_type {
                                                VarType::String => {
                                                    c_code.push_str(&format!("    printf(\"%s\\n\", {});\n", var_name));
                                                }
                                                VarType::Integer => {
                                                    c_code.push_str(&format!("    printf(\"%lld\\n\", {});\n", var_name));
                                                }
                                                VarType::Float => {
                                                    c_code.push_str(&format!("    printf(\"%f\\n\", {});\n", var_name));
                                                }
                                                VarType::Boolean => {
                                                    c_code.push_str(&format!("    printf(\"%s\\n\", {} ? \"true\" : \"false\");\n", var_name));
                                                }
                                            }
                                        } else {
                                            // Если переменная не найдена, предполагаем строку
                                            c_code.push_str(&format!("    printf(\"%s\\n\", {});\n", var_name));
                                        }
                                    }
                                    Expr::Call { .. } => {
                                        c_code.push_str("    // Nested calls not supported yet\n");
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        c_code.push_str("    return 0;\n");
        c_code.push_str("}\n");
        
        c_code
    }

    fn try_compiler(&self, compiler: &str, args: &[&str]) -> Result<(), CompileError> {
        let output = Command::new(compiler)
            .args(args)
            .stdout(Stdio::null())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| CompileError::Io(e.to_string()))?;
        
        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(CompileError::Compilation(format!("{}: {}", compiler, stderr)))
        }
    }

    fn detect_c_compiler(&self) -> Result<&'static str, CompileError> {
        let compilers = if cfg!(target_os = "windows") {
            ["gcc", "clang", "cl"]
        } else {
            ["gcc", "clang", "cc"]
        };

        for &compiler in &compilers {
            if self.try_compiler(compiler, &["--version"]).is_ok() {
                return Ok(compiler);
            }
        }

        Err(CompileError::NoCompiler)
    }

    pub fn compile_to_exe(&self, program: &Program, output_path: &str) -> Result<(), CompileError> {
        let c_code = self.generate_c_code(program);
        let c_file = "quark_temp.c";
        
        // Отладка: показать сгенерированный C код
        println!("Generated C code:\n{}", c_code);
        
        fs::write(c_file, &c_code)
            .map_err(|e| CompileError::Io(e.to_string()))?;

        let compiler = self.detect_c_compiler()?;

        let args: Vec<&str> = match compiler {
            "cl" => vec![c_file, "/Fe:", output_path, "/nologo", "/O2"],
            _ => vec![c_file, "-o", output_path, "-O2", "-s"],
        };

        self.try_compiler(compiler, &args)?;

        let _ = fs::remove_file(c_file);
        
        Ok(())
    }
}