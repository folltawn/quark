use crate::parser::{Program, Stmt, Expr, Value, VarType, BinOp};
use std::fs;
use std::process::{Command, Stdio};

#[derive(Debug)]
pub enum CompileError {
    Parse(String),
    Io(String),
    Compilation(String),
    NoCompiler,
}

pub struct Compiler {
    temp_counter: usize,
}

impl Compiler {
    pub fn new() -> Self {
        Self { temp_counter: 0 }
    }

    fn generate_c_code(&mut self, program: &Program) -> String {
        let mut c_code = String::new();
        
        c_code.push_str("/* Generated by Quark Compiler */\n");
        c_code.push_str("#include <stdio.h>\n");
        c_code.push_str("#include <stdlib.h>\n");
        c_code.push_str("#include <string.h>\n");
        c_code.push_str("#include <stdbool.h>\n\n");
        
        // Собираем все объявленные переменные
        let mut variables = std::collections::HashMap::new();
        
        for stmt in &program.statements {
            if let Stmt::Declaration { var_type, name, .. } = stmt {
                variables.insert(name.clone(), var_type.clone());
            }
        }
        
        // Объявления переменных
        c_code.push_str("// Variables\n");
        for stmt in &program.statements {
            if let Stmt::Declaration { var_type, name, value } = stmt {
                let c_type = match var_type {
                    VarType::String => "const char*",
                    VarType::Integer => "long long",
                    VarType::Float => "double",
                    VarType::Boolean => "bool",
                };
                
                let c_value = match value {
                    Value::String(s) => {
                        let escaped = s
                            .replace('\\', "\\\\")
                            .replace('\"', "\\\"")
                            .replace('\n', "\\n")
                            .replace('\t', "\\t")
                            .replace('\r', "\\r");
                        format!("\"{}\"", escaped)
                    }
                    Value::Integer(i) => i.to_string(),
                    Value::Float(f) => f.to_string(),
                    Value::Boolean(true) => "true".to_string(),
                    Value::Boolean(false) => "false".to_string(),
                };
                
                c_code.push_str(&format!("{} {} = {};\n", c_type, name, c_value));
            }
        }
        
        c_code.push_str("\nint main() {\n");
        
        // Генерация кода
        for stmt in &program.statements {
            match stmt {
                Stmt::Declaration { .. } => {
                    // Объявления уже были выше
                }
                Stmt::Expression(expr) => {
                    if let Expr::Call { name, args } = expr {
                        if name == "echo" {
                            for arg in args {
                                let code = self.generate_echo_expression(arg, &variables);
                                c_code.push_str(&code);
                            }
                        }
                    }
                }
            }
        }
        
        c_code.push_str("    return 0;\n");
        c_code.push_str("}\n");
        
        c_code
    }
    
    fn generate_echo_expression(&mut self, expr: &Expr, 
                               variables: &std::collections::HashMap<String, VarType>) -> String {
        match expr {
            Expr::Literal(value) => {
                match value {
                    Value::String(s) => {
                        let escaped = s
                            .replace('\\', "\\\\")
                            .replace('\"', "\\\"")
                            .replace('\n', "\\n")
                            .replace('\t', "\\t")
                            .replace('\r', "\\r")
                            .replace('%', "%%");
                        format!("    printf(\"{}\\n\");\n", escaped)
                    }
                    Value::Integer(i) => {
                        format!("    printf(\"%lld\\n\", {});\n", i)
                    }
                    Value::Float(f) => {
                        format!("    printf(\"%f\\n\", {});\n", f)
                    }
                    Value::Boolean(b) => {
                        format!("    printf(\"{}\\n\");\n", if *b { "true" } else { "false" })
                    }
                }
            }
            Expr::Variable(var_name) => {
                if let Some(var_type) = variables.get(var_name) {
                    match var_type {
                        VarType::String => {
                            format!("    printf(\"%s\\n\", {});\n", var_name)
                        }
                        VarType::Integer => {
                            format!("    printf(\"%lld\\n\", {});\n", var_name)
                        }
                        VarType::Float => {
                            format!("    printf(\"%f\\n\", {});\n", var_name)
                        }
                        VarType::Boolean => {
                            format!("    printf(\"%s\\n\", {} ? \"true\" : \"false\");\n", var_name)
                        }
                    }
                } else {
                    // Если переменная не найдена, предполагаем строку
                    format!("    printf(\"%s\\n\", {});\n", var_name)
                }
            }
            Expr::BinaryOp { left, op: BinOp::Add, right } => {
                // Генерация кода для сложения строк
                let (left_code, left_var) = self.generate_string_value(left, variables);
                let (right_code, right_var) = self.generate_string_value(right, variables);
                
                let temp_name = format!("temp_concat_{}", self.temp_counter);
                self.temp_counter += 1;
                
                format!("{}{}    char {}[256];\n    snprintf({}, sizeof({}), \"%s%s\", {}, {});\n    printf(\"%s\\n\", {});\n",
                       left_code, right_code, temp_name, temp_name, temp_name, left_var, right_var, temp_name)
            }
            _ => {
                String::from("    // Unsupported expression in echo\n")
            }
        }
    }
    
    fn generate_string_value(&mut self, expr: &Expr, 
                           variables: &std::collections::HashMap<String, VarType>) -> (String, String) {
        match expr {
            Expr::Literal(Value::String(s)) => {
                let escaped = s
                    .replace('\\', "\\\\")
                    .replace('\"', "\\\"")
                    .replace('\n', "\\n")
                    .replace('\t', "\\t")
                    .replace('\r', "\\r");
                (String::new(), format!("\"{}\"", escaped))
            }
            Expr::Variable(var_name) => {
                if let Some(var_type) = variables.get(var_name) {
                    match var_type {
                        VarType::String => (String::new(), var_name.clone()),
                        VarType::Integer => {
                            let temp_name = format!("temp_int_{}", self.temp_counter);
                            self.temp_counter += 1;
                            (format!("    char {}[32];\n    snprintf({}, sizeof({}), \"%lld\", {});\n", 
                                   temp_name, temp_name, temp_name, var_name),
                             temp_name)
                        }
                        VarType::Float => {
                            let temp_name = format!("temp_float_{}", self.temp_counter);
                            self.temp_counter += 1;
                            (format!("    char {}[32];\n    snprintf({}, sizeof({}), \"%f\", {});\n", 
                                   temp_name, temp_name, temp_name, var_name),
                             temp_name)
                        }
                        VarType::Boolean => {
                            let temp_name = format!("temp_bool_{}", self.temp_counter);
                            self.temp_counter += 1;
                            (format!("    const char* {} = {} ? \"true\" : \"false\";\n", temp_name, var_name),
                             temp_name)
                        }
                    }
                } else {
                    (String::new(), var_name.clone())
                }
            }
            Expr::BinaryOp { left, op: BinOp::Add, right } => {
                // Генерация кода для сложения строк
                let (left_code, left_var) = self.generate_string_value(left, variables);
                let (right_code, right_var) = self.generate_string_value(right, variables);
                
                let temp_name = format!("temp_expr_{}", self.temp_counter);
                self.temp_counter += 1;
                
                (format!("{}{}    char {}[256];\n    snprintf({}, sizeof({}), \"%s%s\", {}, {});\n",
                       left_code, right_code, temp_name, temp_name, temp_name, left_var, right_var),
                 temp_name)
            }
            _ => {
                (String::from("    // Unsupported value\n"), String::from("\"\""))
            }
        }
    }

    fn try_compiler(&self, compiler: &str, args: &[&str]) -> Result<(), CompileError> {
        let output = Command::new(compiler)
            .args(args)
            .stdout(Stdio::null())
            .stderr(Stdio::piped())
            .output()
            .map_err(|e| CompileError::Io(e.to_string()))?;
        
        if output.status.success() {
            Ok(())
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr);
            Err(CompileError::Compilation(format!("{}: {}", compiler, stderr)))
        }
    }

    fn detect_c_compiler(&self) -> Result<&'static str, CompileError> {
        let compilers = if cfg!(target_os = "windows") {
            ["gcc", "clang", "cl"]
        } else {
            ["gcc", "clang", "cc"]
        };

        for &compiler in &compilers {
            if self.try_compiler(compiler, &["--version"]).is_ok() {
                return Ok(compiler);
            }
        }

        Err(CompileError::NoCompiler)
    }

    pub fn compile_to_exe(&mut self, program: &Program, output_path: &str) -> Result<(), CompileError> {
        let c_code = self.generate_c_code(program);
        let c_file = "quark_temp.c";
        
        // Отладка: показать сгенерированный C код
        println!("Generated C code:\n{}", c_code);
        
        fs::write(c_file, &c_code)
            .map_err(|e| CompileError::Io(e.to_string()))?;

        let compiler = self.detect_c_compiler()?;

        let args: Vec<&str> = match compiler {
            "cl" => vec![c_file, "/Fe:", output_path, "/nologo", "/O2"],
            _ => vec![c_file, "-o", output_path, "-O2", "-s"],
        };

        self.try_compiler(compiler, &args)?;

        let _ = fs::remove_file(c_file);
        
        Ok(())
    }
}